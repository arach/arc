{
  "project": "arc",
  "version": "0.0.0",
  "generatedAt": "2026-01-15T03:55:15.417Z",
  "sections": [
    {
      "id": "overview",
      "title": "Overview",
      "description": "Diagrams as Code - Visual editor for architecture diagrams that live in your codebase",
      "content": "# Arc Overview\n\nArc is a visual editor for building architecture diagrams that stay in code. You design on a canvas, then export a clean, declarative model that can be stored in Git and rendered anywhere.\n\n## Why Arc?\n\nArchitecture diagrams typically live in design tools, disconnected from the code they describe. Arc keeps diagrams as declarative configs that:\n\n- **Version with your code** - Diffs show exactly what changed\n- **Render anywhere** - Use the lightweight player or export to SVG/PNG\n- **Stay consistent** - Templates enforce color palettes and sizing rules\n\n## Key Features\n\n- **Visual Editor** - Drag-and-drop nodes, connectors, groups, and images\n- **Declarative Exports** - JSON/TypeScript configs designed for version control\n- **Templates** - Built-in themes and sizing presets\n- **Isometric View** - Toggle 3D projection for visual impact\n- **Multiple Export Formats** - JSON, TypeScript, SVG, PNG, clipboard embed\n\n## Packages\n\nArc ships as two npm packages:\n\n| Package | Size | Use Case |\n|---------|------|----------|\n| `@arach/arc` | ~75KB | Full editor + player components |\n| `@arach/arc-player` | ~7KB | Lightweight renderer only |\n\n## Quick Links\n\n- [Quickstart](./quickstart.md) - Get started in 5 minutes\n- [Architecture](./architecture.md) - How the editor is built"
    },
    {
      "id": "quickstart",
      "title": "Quickstart",
      "description": "Get started with Arc in 5 minutes",
      "content": "# Quickstart\n\nGet up and running with Arc in under 5 minutes.\n\n## Prerequisites\n\n- Node.js >= 18\n- React 18 or 19\n\n## Installation\n\n```bash\n# Full editor + player\npnpm add @arach/arc\n\n# Or just the lightweight player\npnpm add @arach/arc-player\n```\n\n## Using the Player\n\nRender a diagram from a declarative config:\n\n```tsx\nimport { ArcDiagram } from '@arach/arc'\n\nconst config = {\n  layout: { width: 600, height: 300 },\n  nodes: {\n    web: { x: 50, y: 100, size: 'm' },\n    api: { x: 250, y: 100, size: 'm' },\n    db: { x: 450, y: 100, size: 'm' },\n  },\n  nodeData: {\n    web: { icon: 'Monitor', name: 'Web App', color: 'blue' },\n    api: { icon: 'Server', name: 'API', color: 'emerald' },\n    db: { icon: 'Database', name: 'Database', color: 'violet' },\n  },\n  connectors: [\n    { from: 'web', to: 'api', fromAnchor: 'right', toAnchor: 'left', style: 'http' },\n    { from: 'api', to: 'db', fromAnchor: 'right', toAnchor: 'left', style: 'sql' },\n  ],\n  connectorStyles: {\n    http: { color: 'amber', strokeWidth: 2, label: 'HTTP' },\n    sql: { color: 'sky', strokeWidth: 2, label: 'SQL' },\n  },\n}\n\nexport default function MyDiagram() {\n  return <ArcDiagram config={config} />\n}\n```\n\n## Using the Editor\n\nEmbed the full editor in your app:\n\n```tsx\nimport { DiagramEditor, EditorProvider } from '@arach/arc'\n\nexport default function Editor() {\n  return (\n    <EditorProvider>\n      <DiagramEditor />\n    </EditorProvider>\n  )\n}\n```\n\n## Vanilla JavaScript\n\nFor non-React environments:\n\n```js\nimport { renderToElement } from '@arach/arc-player'\n\nrenderToElement(document.getElementById('diagram'), config)\n```\n\n## Development\n\nRun the editor locally:\n\n```bash\ngit clone https://github.com/arach/arc\ncd arc\npnpm install\npnpm dev\n```\n\nThe dev server runs on `http://localhost:5188`.\n\n## Next Steps\n\n- [Architecture](./architecture.md) - Understand the editor internals\n- [CLAUDE.md](../CLAUDE.md) - AI agent instructions for this codebase"
    },
    {
      "id": "architecture",
      "title": "Architecture",
      "description": "How the Arc editor is built - state management, modules, and data flow",
      "content": "# Arc Architecture Overview\n\nArc is organized around a single diagram model and a small set of modules that read, edit, and\nexport that model. The goal is to keep editor behavior, state management, and export logic\nseparate so outputs stay stable even as the UI evolves.\n\n## Major Modules\n\n- `src/components/editor/`: The editor shell (top bar, canvas, panels, layers).\n- `src/components/properties/`: Forms for editing node, connector, group, and grid settings.\n- `src/components/dialogs/`: Export and share dialogs.\n- `src/hooks/`: Keyboard shortcuts and canvas transform helpers.\n- `src/utils/`: Diagram helpers, templates, export utilities, and file operations.\n- `src/types/`: TypeScript types for diagram + editor state.\n\n## State Model\n\nState lives in a reducer + context pair (`EditorProvider`, `editorReducer`). The state shape is\nsplit into four slices:\n\n- `diagram`: layout, nodes, nodeData, connectors, connectorStyles, groups, images, exportZone\n- `editor`: selection, mode, pending actions, template, zoom\n- `meta`: filename, dirty state, last saved\n- `history`: undo/redo stacks (capped for performance)\n\nThe reducer records history on meaningful changes and drives all interactions (add/remove nodes,\nupdate connectors, change templates, etc.).\n\n## Data Flow\n\n1. **Input**: The editor dispatches actions from UI events.\n2. **Reducer**: `editorReducer` updates the diagram and tracks history.\n3. **Canvas**: `DiagramCanvas` renders nodes, connectors, groups, and images.\n4. **Properties**: The panel writes updates back to the reducer.\n5. **Export**: `exportUtils` and `fileOperations` serialize the model for external use.\n\n## Diagram Config\n\nExported diagrams are declarative and designed to be embedded elsewhere:\n\n```ts\n{\n  layout: { width: 1200, height: 700 },\n  nodes: { api: { x: 80, y: 120, size: 'm' } },\n  nodeData: { api: { icon: 'Server', name: 'API', color: 'emerald' } },\n  connectors: [\n    { from: 'web', to: 'api', fromAnchor: 'right', toAnchor: 'left', style: 'http' }\n  ],\n  connectorStyles: { http: { color: 'amber', strokeWidth: 2, label: 'HTTP' } }\n}\n```\n\nKeep configs in version control so architecture updates travel with the product."
    }
  ]
}